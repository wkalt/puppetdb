# Classifier

A service for classifying puppet nodes based on user-defined rules.

# Getting Started

NB: This is in an early stage of development.
These instructions are really only useful if you want to develop on the classifier.

To run the classifier you will need:

* Postgres
* A JVM
* [Leiningen](http://leiningen.org)

First, create a fresh postgres database for the classifier.
This can be done as a postgres superuser (usually `su - postgres` on a default installation).
Here's an example of creating the user and database, both with a name of `classifier`:

```
createuser -d pe-classifier -P
createdb pe-classifier -U pe-classifier
```

The first command will prompt for the user's password.

If using classifier in Puppet Enterprise, the following steps should be used:
`su - pe-postgres -s /bin/bash -c /opt/puppet/bin/psql`

```
CREATE USER "pe-classifier" PASSWORD '<PASSWORD>';
CREATE DATABASE "pe-classifier" OWNER "pe-classifier" ENCODING 'utf8' LC_CTYPE 'en_US.utf8' LC_COLLATE 'en_US.utf8' template template0;
```

Edit (or copy to another location) the `resources/ext/config/conf.d/classifier.conf` configuration file and add a `database` section inside the classifier hash with the subname (database name), user, and password.
For the example above, assuming `pe-classifier` was entered for the user's password, this section should look like:

```
classifier: {
  [...]
  database: {
    subname: pe-classifier,
    user: pe-classifier,
    password: pe-classifier
  }
}
```

Now you can start the service with (use the path to the location of your conf file):

```
lein run --config <path_to_your>/classifier.conf
```

Once the service is running, you can give it a rough smoke test by creating a simple group hierarchy and using it to classify a node.

First, add a class that you can reference in your groups.
Note that, when using the classifier with Puppet, all class definitions will be pulled from the master, but for this smoke test you'll use (undocumented) API routes to define the class. We don't recommend using these calls in production. See the [Using the Classifier with Puppet](#using-the-classifier-with-puppet) section for more details.

```sh
curl -X PUT -H 'Content-Type: application/json' \
  -d '{ "name": "apache",
        "environment": "production",
        "parameters": {
          "confd_dir": "/etc/apache2",
          "mod_dir": "/etc/apache2/mods-available",
          "logroot": "/var/log/apache2"
        }
      }' \
  http://localhost:1261/v1/environments/production/classes/apache
```

If all went well, the output from curl should echo back the same class JSON object that you submitted.

Now, you can create a group that uses this class.

```sh
curl -X PUT -H 'Content-Type: application/json' \
-d '{
  "id": "ddab2071-26ea-4261-af09-7b6b97fa04c2",
  "name": "webservers",
  "environment": "production",
  "parent": "00000000-0000-4000-8000-000000000000",
  "rule": ["~", "name", "\\.www\\.example\\.com$"],
  "classes": {
    "apache": {
      "confd_dir": "/opt/mywebapp/etc/apache2",
      "logroot": "/opt/mywebapp/log"
    }
  }
}' \
  http://localhost:1261/v1/groups/ddab2071-26ea-4261-af09-7b6b97fa04c2
```

Again, if you see the group object that was submitted echoed back in curl's output, then the submission worked.

Now you can classify a node:

```sh
curl http://localhost:1261/v1/classified/nodes/argon.atlanta.www.example.com
```

The response should be:

```json
{
   "name" : "argon.atlanta.www.example.com",
   "parameters" : {
      "apache" : {
         "confd_dir": "/opt/mywebapp/etc/apache2",
         "logroot" : "/opt/mywebapp/log"
      }
   },
   "classes" : [
      "apache"
   ],
   "variables" : {},
   "groups" : [
      "webservers"
   ],
   "environment" : "production"
}
```

It worked!
As you can see, the node was classified into the `webservers` group that you created, and picked up the parameters that the group set for the `apache` class.

# Running tests

First, make sure you have a `classifier_test` database accessible by a `classifier_test`
role with the password `classifier_test`. Then run `lein test`.

# Using the Classifier with Puppet

For most uses, you'll want to actually connect the classifier service to Puppet. There are a few steps to follow if you're doing this on your own. Note that this requires Puppet >= 3.6 (Puppet Enterprise >= 3.3).

## Configure the classifier to use puppet-valid certificates when connecting to the master

You'll need a certificate generated by the same CA that your Puppet infrastructure uses. For setups where the classifier service is running on the same host as a puppetmaster, you can (barring Unix permission) reuse the same certificate that the Puppet master itself uses.  Find the locations of your puppet master's CA certificate, server cert, and server cert's private key:

```
puppet master --configprint localcacert
puppet master --configprint hostcert
puppet master --configprint hostprivkey
```

These values then, respectively, get set as `ssl-ca-cert`, `ssl-cert`, and `ssl-key` in the `classifier` stanza of your `classifier.conf` file. You'll also need to tell the classifier where to reach the puppet master's REST interface. On a single-master puppet enterprise installation on the host `glitch.domain.com`, for example, this ends up looking like:

```
classifier: {
  puppet-master: "https://glitch.domain.com:8140"

  ssl-key: /etc/puppetlabs/puppet/ssl/private_keys/glitch.domain.com.pem
  ssl-cert: /etc/puppetlabs/puppet/ssl/certs/glitch.domain.com.pem
  ssl-ca-cert: /etc/puppetlabs/puppet/ssl/certs/ca.pem
}
```

Note that if SSL is configured for the webserver, but not for connections to the master, then the webserver SSL configuration will be used for master connections.

## Configure the classifier to use puppet-valid certificates to serve its API

The certificates that the classifier uses to serve its API over SSL are configured seperately from those it uses to connect to the master.
This is to allow you to use different certificates for these two functions (to, e.g. mitigate the impact of any one certificate becoming compromised), though here we'll just reuse the master's again.
The cert, key, and ca-cert for the webserver are configured by setting, respectively, the `ssl-cert`, `ssl-key`, and `ssl-ca-cert` configuration keys in the `webserver: classifier` stanza of your `classifier.conf` file.
You'll also need to set the `ssl-host` and `ssl-port` keys in the same section.

```
webserver: {
  classifier: {
    ssl-key: /etc/puppetlabs/puppet/ssl/private_keys/glitch.domain.com.pem
    ssl-cert: /etc/puppetlabs/puppet/ssl/certs/glitch.domain.com.pem
    ssl-ca-cert: /etc/puppetlabs/puppet/ssl/certs/ca.pem

    ssl-host: 0.0.0.0
    ssl-port: 1262
  }
}
```

## Configure the puppetmaster's auth.conf

Next, the puppetmaster needs to permit access to REST endpoints used by the classifier for the certificate you used in the previous step. (This may be configured out of the box in newer versions of Puppet). This happens in the puppetmaster's `$confdir/auth.conf` file, which is evaluated top-down and contains a default-deny rule at the bottom. So make sure there's a stanza like this somewhere above the bottom line:

```
path /v2.0/environments
method find
allow *
```

## Configure Puppet to use the classifier terminus

Somehow you need to get the contents of the `puppet/` subdirectory into the Ruby load path of your master. If running puppet and classifier both from source, setting the `$RUBYLIB` enviroment variable will do this; if you're running from packaged artifacts the files may be installed in a place where Puppet will find them by the packages.

Then configure puppet to use the classifer when nodes check in by setting the following in your `$confdir/puppet.conf`:

```
[main]
node_terminus = classifier
```

## Point the classifier terminus at the classifier service

Next you need to tell the classifier node terminus we configured in the previous step how to talk to the classifier service; this configurability is overkill for the single-node setup, but often puppetmasters will run on different systems from the classifier service.

Create a YAML file at `$confdir/classifier.yaml`, which should contain two simple keys, `server` and `port`. For example:

```
server: localhost
port: 1262
```

Make sure whatever hostname you use for 'server' is resolvable and matches the certificate subject name in the `hostcert` the classifier is using.
